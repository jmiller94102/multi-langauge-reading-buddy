/**
 * Korean Blend System - Real-Time 6-Level Language Blending
 *
 * This system provides real-time blending between English (primary) and Korean (secondary)
 * content based on a 6-level sliding scale. No additional LLM calls are needed since
 * both language versions are pre-generated by the backend.
 */

interface StoryData {
  englishContent: string;
  koreanContent: string;
  englishSentences: string[];
  koreanSentences: string[];
  nounMappings: { [englishWord: string]: string };
  customVocabulary?: string[]; // Array of custom vocabulary words from the user
}

interface BlendedContent {
  html: string;
  level: number;
  description: string;
}

/**
 * 7-Level Blending System Definitions
 */
export const BLEND_LEVELS = [
  {
    level: 0,
    name: "Pure English",
    emoji: "üá∫üá∏",
    description: "100% English sentences - Perfect for beginners!",
    shortDesc: "Pure English"
  },
  {
    level: 1,
    name: "English + Korean Noun Hints",
    emoji: "üå±",
    description: "English sentences with Korean noun hints",
    shortDesc: "Korean vocabulary hints"
  },
  {
    level: 2,
    name: "English Dominant",
    emoji: "üìö",
    description: "2 English + 1 Korean sentence (2:1 ratio)",
    shortDesc: "English dominant (2:1)"
  },
  {
    level: 3,
    name: "Balanced",
    emoji: "‚öñÔ∏è",
    description: "Alternating English and Korean sentences (1:1)",
    shortDesc: "Balanced mixing (1:1)"
  },
  {
    level: 4,
    name: "Korean Dominant",
    emoji: "üîÑ",
    description: "1 English + 2 Korean sentences (1:2 ratio)",
    shortDesc: "Korean dominant (1:2)"
  },
  {
    level: 5,
    name: "Korean + English Noun Hints",
    emoji: "üè¥‚Äç‚ò†Ô∏è",
    description: "Korean sentences with English noun hints",
    shortDesc: "Korean with English hints"
  },
  {
    level: 6,
    name: "Pure Korean",
    emoji: "üá∞üá∑",
    description: "100% Korean sentences - Full immersion!",
    shortDesc: "Pure Korean"
  }
];

/**
 * Generate real-time blended content based on the selected level
 */
export function generateBlendedContent(storyData: StoryData, level: number): BlendedContent {
  const levelInfo = BLEND_LEVELS[level] || BLEND_LEVELS[0];

  switch (level) {
    case 0:
      return {
        html: generateLevel0(storyData),
        level,
        description: levelInfo.description
      };

    case 1:
      return {
        html: generateLevel1(storyData),
        level,
        description: levelInfo.description
      };

    case 2:
      return {
        html: generateLevel2(storyData),
        level,
        description: levelInfo.description
      };

    case 3:
      return {
        html: generateLevel3(storyData),
        level,
        description: levelInfo.description
      };

    case 4:
      return {
        html: generateLevel4(storyData),
        level,
        description: levelInfo.description
      };

    case 5:
      return {
        html: generateLevel5(storyData),
        level,
        description: levelInfo.description
      };

    case 6:
      return {
        html: generateLevel6(storyData),
        level,
        description: levelInfo.description
      };

    default:
      return generateBlendedContent(storyData, 0);
  }
}

/**
 * Level 0: Pure English (üá∫üá∏)
 * 100% English content in natural paragraph format
 */
function generateLevel0(storyData: StoryData): string {
  // Return the original English content with proper paragraph formatting
  const paragraphs = storyData.englishContent.split('\n\n');

  return paragraphs.map(paragraph => {
    const cleanedParagraph = cleanQuotationMarks(paragraph.trim());
    const boldedParagraph = makeCustomVocabularyBold(cleanedParagraph, storyData.customVocabulary);
    return `<div class="paragraph english-paragraph">${boldedParagraph}</div>`;
  }).join('<div class="paragraph-break"></div>');
}

/**
 * Level 1: English + Korean Noun Hints (üå±)
 * 100% English content with Korean noun hints in natural paragraph format
 */
function generateLevel1(storyData: StoryData): string {
  const paragraphs = storyData.englishContent.split('\n\n');

  return paragraphs.map(paragraph => {
    const cleanedParagraph = cleanQuotationMarks(paragraph.trim());
    const enhancedParagraph = addKoreanHints(cleanedParagraph, storyData.nounMappings, storyData.customVocabulary);
    return `<div class="paragraph english-paragraph">${enhancedParagraph}</div>`;
  }).join('<div class="paragraph-break"></div>');
}

/**
 * Level 2: English Dominant - 2:1 Ratio (üìö)
 * Natural flowing text with 2 English + 1 full Korean sentence with full English translation hint
 */
function generateLevel2(storyData: StoryData): string {
  const { englishSentences, koreanSentences, nounMappings: _nounMappings } = storyData;

  // Group sentences into paragraphs (approximately 3-4 sentences per paragraph)
  const paragraphs: string[] = [];
  const maxSentences = Math.max(englishSentences.length, koreanSentences.length);
  const sentencesPerParagraph = 6; // 2 cycles of 3 sentences each

  for (let paragraphStart = 0; paragraphStart < maxSentences; paragraphStart += sentencesPerParagraph) {
    const paragraphSentences: string[] = [];

    for (let i = paragraphStart; i < Math.min(paragraphStart + sentencesPerParagraph, maxSentences); i += 3) {
      // Add 2 English sentences with bold custom vocabulary
      for (let j = 0; j < 2 && (i + j) < englishSentences.length; j++) {
        const sentence = cleanQuotationMarks(englishSentences[i + j]);
        const boldedSentence = makeCustomVocabularyBold(sentence, storyData.customVocabulary);
        paragraphSentences.push(`${boldedSentence}.`);
      }

      // Add 1 full Korean sentence with complete English translation as hint
      if ((i + 2) < koreanSentences.length) {
        const koreanSentence = koreanSentences[i + 2];
        const englishTranslation = englishSentences[i + 2] || '';

        // Add the Korean sentence with bold custom vocabulary and full English translation in parentheses
        const boldedKorean = makeCustomVocabularyBold(koreanSentence, storyData.customVocabulary);

        // Only add hint if translation exists, otherwise just the Korean text
        if (englishTranslation.trim()) {
          paragraphSentences.push(
            addTranslationHintWithQuotePreservation(boldedKorean, englishTranslation)
          );
        } else {
          paragraphSentences.push(`<span class="korean-text">${boldedKorean}.</span>`);
        }
      }
    }

    if (paragraphSentences.length > 0) {
      paragraphs.push(`<div class="paragraph mixed-paragraph">${paragraphSentences.join(' ')}</div>`);
    }
  }

  return paragraphs.join('<div class="paragraph-break"></div>');
}

/**
 * Level 3: Balanced - 1:1 Ratio (‚öñÔ∏è)
 * Natural flowing text alternating English and Korean sentences
 */
function generateLevel3(storyData: StoryData): string {
  const { englishSentences, koreanSentences, nounMappings } = storyData;

  // Group sentences into paragraphs (approximately 4-6 sentences per paragraph)
  const paragraphs: string[] = [];
  const maxSentences = Math.max(englishSentences.length, koreanSentences.length);
  const sentencesPerParagraph = 6; // 3 cycles of 2 sentences each

  for (let paragraphStart = 0; paragraphStart < maxSentences; paragraphStart += sentencesPerParagraph) {
    const paragraphSentences: string[] = [];

    for (let i = paragraphStart; i < Math.min(paragraphStart + sentencesPerParagraph, maxSentences); i += 2) {
      // Add 1 English sentence with Korean hints
      if (i < englishSentences.length) {
        const sentence = englishSentences[i];
        const enhanced = addKoreanHints(sentence, nounMappings, storyData.customVocabulary);
        paragraphSentences.push(`${enhanced}.`);
      }

      // Add 1 Korean sentence with English hints
      if ((i + 1) < koreanSentences.length) {
        const sentence = koreanSentences[i + 1];
        const enhanced = addEnglishHints(sentence, nounMappings, storyData.customVocabulary);
        paragraphSentences.push(`<span class="korean-text">${enhanced}.</span>`);
      }
    }

    if (paragraphSentences.length > 0) {
      paragraphs.push(`<div class="paragraph mixed-paragraph">${paragraphSentences.join(' ')}</div>`);
    }
  }

  return paragraphs.join('<div class="paragraph-break"></div>');
}

/**
 * Level 4: Korean Dominant - 1:2 Ratio (üîÑ)
 * Natural flowing text with 1 English + 2 Korean sentence ratios
 */
function generateLevel4(storyData: StoryData): string {
  const { englishSentences, koreanSentences, nounMappings } = storyData;

  // Group sentences into paragraphs (approximately 6 sentences per paragraph)
  const paragraphs: string[] = [];
  const maxSentences = Math.max(englishSentences.length, koreanSentences.length);
  const sentencesPerParagraph = 6; // 2 cycles of 3 sentences each

  for (let paragraphStart = 0; paragraphStart < maxSentences; paragraphStart += sentencesPerParagraph) {
    const paragraphSentences: string[] = [];

    for (let i = paragraphStart; i < Math.min(paragraphStart + sentencesPerParagraph, maxSentences); i += 3) {
      // Add 1 English sentence with Korean hints
      if (i < englishSentences.length) {
        const sentence = englishSentences[i];
        const enhanced = addKoreanHints(sentence, nounMappings, storyData.customVocabulary);
        paragraphSentences.push(`${enhanced}.`);
      }

      // Add 2 Korean sentences with English hints
      for (let j = 1; j < 3 && (i + j) < koreanSentences.length; j++) {
        const sentence = koreanSentences[i + j];
        const enhanced = addEnglishHints(sentence, nounMappings, storyData.customVocabulary);
        paragraphSentences.push(`<span class="korean-text">${enhanced}.</span>`);
      }
    }

    if (paragraphSentences.length > 0) {
      paragraphs.push(`<div class="paragraph mixed-paragraph">${paragraphSentences.join(' ')}</div>`);
    }
  }

  return paragraphs.join('<div class="paragraph-break"></div>');
}

/**
 * Level 5: Korean + English Noun Hints (üè¥‚Äç‚ò†Ô∏è)
 * 100% Korean content with English noun hints in natural paragraph format
 */
function generateLevel5(storyData: StoryData): string {
  const paragraphs = storyData.koreanContent.split('\n\n');

  return paragraphs.map(paragraph => {
    const enhancedParagraph = addEnglishHints(paragraph.trim(), storyData.nounMappings, storyData.customVocabulary);
    return `<div class="paragraph korean-paragraph">${enhancedParagraph}</div>`;
  }).join('<div class="paragraph-break"></div>');
}

/**
 * Level 6: Pure Korean (üá∞üá∑)
 * 100% Korean content in natural paragraph format (no hints)
 */
function generateLevel6(storyData: StoryData): string {
  const paragraphs = storyData.koreanContent.split('\n\n');

  return paragraphs.map(paragraph => {
    const boldedParagraph = makeCustomVocabularyBold(paragraph.trim(), storyData.customVocabulary);
    return `<div class="paragraph korean-paragraph">${boldedParagraph}</div>`;
  }).join('<div class="paragraph-break"></div>');
}

/**
 * Make custom vocabulary words bold in the text
 */
function makeCustomVocabularyBold(text: string, customVocabulary?: string[]): string {
  if (!customVocabulary || customVocabulary.length === 0) {
    return text;
  }

  let result = text;
  customVocabulary.forEach(word => {
    // Create regex to match the word with word boundaries
    const regex = new RegExp(`\\b${word}\\b`, 'gi');
    result = result.replace(regex, (match) => `<strong>${match}</strong>`);
  });

  return result;
}

/**
 * Helper function to insert hints with proper spacing based on punctuation
 */
function insertHintWithProperSpacing(text: string, match: string, matchIndex: number, hint: string): string {
  const nextCharIndex = matchIndex + match.length;
  const nextChar = nextCharIndex < text.length ? text.charAt(nextCharIndex) : '';
  const isPunctuationNext = /[.,!?;:"']/.test(nextChar);
  const spacing = isPunctuationNext ? '' : ' ';
  return `${match}${spacing}<span class="secondary-hint">(${hint})</span>`;
}

/**
 * Helper function to clean up quotation marks (minimal processing)
 * Backend should handle proper sentence splitting, frontend just cleans minor issues
 */
function cleanQuotationMarks(text: string): string {
  // Minimal cleanup - backend should handle the heavy lifting
  return text.trim();
}

/**
 * Helper function to add translation hints with cleaned quotation marks
 */
function addTranslationHintWithQuotePreservation(koreanSentence: string, englishTranslation: string): string {
  // Clean up quotation marks in both sentences
  const cleanKorean = cleanQuotationMarks(koreanSentence.replace(/\.$/, ''));
  const cleanEnglish = cleanQuotationMarks(englishTranslation.replace(/\.$/, ''));
  
  return `<span class="korean-text">${cleanKorean}.</span> <span class="secondary-hint">(${cleanEnglish})</span>`;
}

/**
 * Add Korean hints to English sentences
 * Format: word (ÌïúÍµ≠Ïñ¥) where Korean text is italic + gold
 * Quote-aware: Avoids breaking quoted speech
 * Punctuation-aware: No extra space before punctuation
 */
function addKoreanHints(englishSentence: string, nounMappings: { [key: string]: string }, customVocabulary?: string[]): string {
  let result = englishSentence;

  // First make custom vocabulary bold
  result = makeCustomVocabularyBold(result, customVocabulary);

  // Quote-aware and punctuation-aware hint addition function
  const addHintsToText = (text: string, mappings: { [key: string]: string }) => {
    let processedText = text;
    Object.entries(mappings).forEach(([english, korean]) => {
      // Only add hints outside of quoted speech
      const regex = new RegExp(`\\b${english}\\b(?=(?:[^"]*"[^"]*")*[^"]*$)`, 'gi');
      processedText = processedText.replace(regex, (match, offset) =>
        insertHintWithProperSpacing(processedText, match, offset, korean)
      );
    });
    return processedText;
  };

  // Add Korean hints for mapped nouns (quote-aware)
  result = addHintsToText(result, nounMappings);

  // For Level 1, we now use dynamic mappings from the LLM translation
  // Only add fallback mappings if the LLM didn't provide enough
  const additionalMappings = Object.keys(nounMappings).length < 10 ? {
    // Nouns
    'ball': 'Í≥µ',
    'team': 'ÌåÄ',
    'game': 'Í≤åÏûÑ',
    'goal': 'Í≥®',
    'player': 'ÏÑ†Ïàò',
    'field': 'ÌïÑÎìú',
    'coach': 'ÏΩîÏπò',
    'score': 'Ï†êÏàò',
    'match': 'Í≤ΩÍ∏∞',
    'champion': 'Ï±îÌîºÏñ∏',
    'victory': 'ÏäπÎ¶¨',
    'crowd': 'Í¥ÄÏ§ë',
    'stadium': 'Í≤ΩÍ∏∞Ïû•',
    'soccer': 'Ï∂ïÍµ¨',

    // Verbs (base form and common conjugations)
    'run': 'Îã¨Î¶¨Îã§',
    'runs': 'Îã¨Î¶∞Îã§',
    'running': 'Îã¨Î¶¨Îäî',
    'ran': 'Îã¨Î†∏Îã§',
    'jump': 'Îõ∞Îã§',
    'jumps': 'Îõ¥Îã§',
    'jumping': 'Îõ∞Îäî',
    'jumped': 'Îõ∞ÏóàÎã§',
    'play': 'ÎÜÄÎã§',
    'plays': 'ÎÖºÎã§',
    'playing': 'ÎÖ∏Îäî',
    'played': 'ÎÜÄÏïòÎã§',
    'kick': 'Ï∞®Îã§',
    'kicks': 'Ï∞¨Îã§',
    'kicking': 'Ï∞®Îäî',
    'kicked': 'Ï∞ºÎã§',
    'throw': 'ÎçòÏßÄÎã§',
    'throws': 'ÎçòÏßÑÎã§',
    'throwing': 'ÎçòÏßÄÎäî',
    'threw': 'ÎçòÏ°åÎã§',
    'catch': 'Ïû°Îã§',
    'catches': 'Ïû°ÎäîÎã§',
    'catching': 'Ïû°Îäî',
    'caught': 'Ïû°ÏïòÎã§',
    'win': 'Ïù¥Í∏∞Îã§',
    'wins': 'Ïù¥Í∏¥Îã§',
    'winning': 'Ïù¥Í∏∞Îäî',
    'won': 'Ïù¥Í≤ºÎã§',
    'lose': 'ÏßÄÎã§',
    'loses': 'ÏßÑÎã§',
    'losing': 'ÏßÄÎäî',
    'lost': 'Ï°åÎã§',
    'cheer': 'ÏùëÏõêÌïòÎã§',
    'cheers': 'ÏùëÏõêÌïúÎã§',
    'cheering': 'ÏùëÏõêÌïòÎäî',
    'cheered': 'ÏùëÏõêÌñàÎã§',
    'practice': 'Ïó∞ÏäµÌïòÎã§',
    'practices': 'Ïó∞ÏäµÌïúÎã§',
    'practicing': 'Ïó∞ÏäµÌïòÎäî',
    'practiced': 'Ïó∞ÏäµÌñàÎã§',
    'learn': 'Î∞∞Ïö∞Îã§',
    'learns': 'Î∞∞Ïö¥Îã§',
    'learning': 'Î∞∞Ïö∞Îäî',
    'learned': 'Î∞∞Ïõ†Îã§',
    'teach': 'Í∞ÄÎ•¥ÏπòÎã§',
    'teaches': 'Í∞ÄÎ•¥ÏπúÎã§',
    'teaching': 'Í∞ÄÎ•¥ÏπòÎäî',
    'taught': 'Í∞ÄÎ•¥Ï≥§Îã§',
    'help': 'ÎèïÎã§',
    'helps': 'ÎèïÎäîÎã§',
    'helping': 'ÎèïÎäî',
    'helped': 'ÎèÑÏôîÎã§',
    'try': 'ÏãúÎèÑÌïòÎã§',
    'tries': 'ÏãúÎèÑÌïúÎã§',
    'trying': 'ÏãúÎèÑÌïòÎäî',
    'tried': 'ÏãúÎèÑÌñàÎã§',

    // Adjectives
    'fast': 'Îπ†Î•∏',
    'strong': 'Í∞ïÌïú',
    'happy': 'ÌñâÎ≥µÌïú',
    'excited': 'Ìù•ÎØ∏ÏßÑÏßÑÌïú',
    'nervous': 'Í∏¥Ïû•Ìïú',
    'proud': 'ÏûêÎûëÏä§Îü¨Ïö¥',
    'brave': 'Ïö©Í∞êÌïú',
    'smart': 'ÎòëÎòëÌïú',
    'funny': 'Ïû¨ÎØ∏ÏûàÎäî',
    'kind': 'ÏπúÏ†àÌïú'
  } : {}; // If we have good LLM mappings, don't use static fallback

  // Add additional hints that weren't already covered (quote-aware)
  const filteredAdditionalMappings = Object.fromEntries(
    Object.entries(additionalMappings).filter(([english]) => !nounMappings[english])
  );
  result = addHintsToText(result, filteredAdditionalMappings);

  return result;
}

/**
 * Add English hints to Korean sentences
 * Format: Îã®Ïñ¥ (word) where English text is italic + gold
 * Quote-aware: Avoids breaking quoted speech
 * Punctuation-aware: No extra space before punctuation
 */
function addEnglishHints(koreanSentence: string, nounMappings: { [key: string]: string }, customVocabulary?: string[]): string {
  let result = koreanSentence;

  // First make custom vocabulary Korean equivalents bold
  if (customVocabulary) {
    customVocabulary.forEach(englishWord => {
      const koreanWord = nounMappings[englishWord.toLowerCase()];
      if (koreanWord) {
        const regex = new RegExp(koreanWord, 'g');
        result = result.replace(regex, (match) => `<strong>${match}</strong>`);
      }
    });
  }

  // Quote-aware and punctuation-aware hint addition function for Korean
  const addKoreanHintsToText = (text: string, mappings: { [key: string]: string }) => {
    let processedText = text;
    Object.entries(mappings).forEach(([english, korean]) => {
      // Escape special regex characters in Korean word
      const escapedKorean = korean.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      // Only add hints outside of quoted speech (Korean quotes use "")
      const regex = new RegExp(`${escapedKorean}(?=(?:[^"]*"[^"]*")*[^"]*$)`, 'g');

      // Check if the Korean word exists in the sentence
      if (text.includes(korean)) {
        processedText = processedText.replace(regex, (match, offset) =>
          insertHintWithProperSpacing(processedText, match, offset, english)
        );
      }
    });
    return processedText;
  };

  // Add English hints for mapped nouns (quote-aware)
  result = addKoreanHintsToText(result, nounMappings);

  // If no mappings found, add some common ones for testing (quote-aware)
  if (result === koreanSentence) {
    // Add some basic Korean-English mappings for common words
    const testMappings = {
      'ÏπúÍµ¨': 'friend',
      'Ï∂ïÍµ¨': 'soccer',
      'Í≤åÏûÑ': 'game',
      'ÌåÄ': 'team',
      'Í≥®': 'goal',
      'Í≥µ': 'ball',
      'ÌïôÍµê': 'school',
      'ÏïÑÏù¥': 'child'
    };

    result = addKoreanHintsToText(result, testMappings);
  }

  return result;
}

/**
 * Get level information for UI display
 */
export function getLevelInfo(level: number) {
  return BLEND_LEVELS[level] || BLEND_LEVELS[0];
}

/**
 * CSS classes for styling (to be applied in the component)
 */
export const BLEND_STYLES = `
  .paragraph {
    margin-bottom: 16px;
    line-height: 1.8;
    font-size: 15px;
    text-align: justify;
    min-height: 1.8em; /* Stabilize paragraph height */
  }

  .english-paragraph {
    font-family: 'Inter', system-ui, sans-serif;
    font-size: 15px;
    font-weight: 400;
    color: rgb(255, 255, 255); /* White text for English paragraphs */
  }

  .korean-paragraph {
    font-family: 'Noto Sans KR', 'Inter', sans-serif;
    font-size: 15px; /* Same as English */
    font-weight: 400; /* Same as English */
    letter-spacing: 0.3px; /* Slight spacing for Korean readability */
    color: rgb(255, 255, 255); /* White text for Korean paragraphs */
  }

  .mixed-paragraph {
    font-family: 'Inter', 'Noto Sans KR', system-ui, sans-serif;
    font-size: 15px;
    font-weight: 400;
  }

  .korean-text {
    font-family: 'Noto Sans KR', sans-serif;
    font-size: 15px; /* Same as English */
    font-weight: 400; /* Same as English */
    letter-spacing: 0.3px;
    color: rgb(255, 255, 255) !important; /* Force white text color */
  }

  .sentence {
    margin-bottom: 8px;
    line-height: 1.6;
    font-size: 15px;
  }

  .english-sentence {
    font-size: 15px;
    font-weight: 400;
  }

  .korean-sentence {
    font-family: 'Noto Sans KR', sans-serif;
    font-size: 15px; /* Same as English */
    font-weight: 400; /* Same as English */
  }

  .secondary-hint {
    color: #fbbf24 !important; /* Gold color only for hints - force override */
    font-style: italic !important;
    font-weight: 400 !important;
    font-size: 0.9em !important; /* 10% smaller than normal font */
    font-family: 'Noto Sans KR', sans-serif !important;
    display: inline !important;
    opacity: 0.65 !important; /* Lower opacity for subtle hints */
    margin-left: 2px;
  }

  .paragraph-break {
    height: 8px;
  }
`;